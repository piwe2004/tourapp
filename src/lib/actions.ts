"use server";

import { PlanItem } from "@/types/place";
import { geminiModel } from "./gemini";
import { db } from "@/lib/firebase";
import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
  Timestamp,
  collection,
  getDocs,
  query,
  limit,
  where,
} from "firebase/firestore";
import { headers } from "next/headers";
import { FirebasePlace } from "@/types/places";
export type { FirebasePlace };

// TODO: Replace with your actual deployed Cloud Function URL
// Example: https://us-central1-your-project-id.cloudfunctions.net/generateOptimizedRoute
const OPTIMIZE_API_URL =
  "https://us-central1-tourapp-a8507.cloudfunctions.net/generateOptimizedRoute";

/**
 * @desc Call Cloud Function to optimize route
 */
async function optimizeRoute(
  places: FirebasePlace[],
  preferences: string
): Promise<FirebasePlace[]> {
  if (!OPTIMIZE_API_URL) {
    console.warn(
      "[Server] OPTIMIZE_API_URL is not set. Skipping optimization."
    );
    return places;
  }

  try {
    console.log("[Server] Requesting route optimization...");
    const response = await fetch(OPTIMIZE_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ places, preferences }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API Error ${response.status}: ${errorText}`);
    }

    const data = await response.json();
    if (data.optimized_route && Array.isArray(data.optimized_route)) {
      console.log("[Server] Route optimized successfully.");
      return data.optimized_route;
    }

    return places;
  } catch (error) {
    console.warn(
      "[Server] Route optimization failed, using original order:",
      error
    );
    return places;
  }
}

import { mapPlaceToPlanItem } from "@/lib/mappers";

// (Removed internal mapPlaceToPlanItem function)

// Firebase에서 실제 데이터를 가져옵니다.
export async function getTravelPlan(destination: string): Promise<PlanItem[]> {
  console.log(`[Server] "${destination}" 데이터 요청 (Firebase)`);

  try {
    const placesRef = collection(db, "PLACES");
    const rawPlaces: FirebasePlace[] = [];

    // 1. Destination 기반 쿼리
    // destination이 주소의 가장 앞부분(지역명)이라고 가정하고 Range Filter 사용
    let q;
    if (destination) {
      q = query(
        placesRef,
        where("ADDRESS", ">=", destination),
        where("ADDRESS", "<=", destination + "\uf8ff"),
        limit(20)
      );
    } else {
      q = query(placesRef, limit(20));
    }

    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      console.warn(
        `[Server] "${destination}" 관련 데이터가 없습니다.`
      );
      return [];
    } else {
      querySnapshot.forEach((doc) => {
        rawPlaces.push(doc.data() as FirebasePlace);
      });
    }

    if (rawPlaces.length === 0) {
      return [];
    }

    // 2. 경로 최적화 (Cloud Function 호출) - [Disabled as per user request]
    const optimizedPlaces = rawPlaces; 

    // 3. PlanItem 변환 및 시간 할당
    const items: PlanItem[] = [];
    let dayCounter = 1;
    let timeCounter = 9; // 9시부터 시작

    optimizedPlaces.forEach((placeData) => {
      // 시간/날짜 단순 분배 로직 (데모용)
      const timeStr = `${String(timeCounter).padStart(2, "0")}:00`;

      items.push(mapPlaceToPlanItem(placeData, dayCounter, timeStr));

      timeCounter += 2;
      if (timeCounter > 20) {
        timeCounter = 9;
        dayCounter += 1;
      }
    });

    console.log(`[Server] ${items.length}개의 장소를 가져왔습니다.`);
    return items;
  } catch (error) {
    console.error("[Server] Firebase 데이터 가져오기 실패:", error);
    return []; // 에러 시 빈 배열 반환
  }
}

export interface TravelContext {
  destination: string | null;
  theme: string[];
  tripSummary?: {
    autoGeneratedTheme: string;
    destination: string;
    totalPlaces: number;
  };
  party: {
    adult: number;
    child: number;
  };
  dateRange: {
    start: string; // YYYY-MM-DD
    end: string; // YYYY-MM-DD
  };
  itinerary?: {
    day: number;
    date?: string;
    dayFocus?: string;
    places: PlanItem[];
  }[];
}

/**
 * @desc IP 기반 속도 제한 (1분에 5회)
 * @param ip 사용자 IP 주소
 * @returns 통과 여부 (true: 통과, false: 차단)
 */
async function checkRateLimit(ip: string): Promise<boolean> {
  // 로컬호스트나 IP가 없는 경우 제한 없이 통과
  if (!ip || ip === "unknown") return true;

  const ref = doc(db, "rate_limits", ip);
  const snapshot = await getDoc(ref);
  const now = Date.now();
  const ONE_MINUTE = 60 * 1000;

  if (!snapshot.exists()) {
    // 첫 요청: 문서 생성
    await setDoc(ref, {
      count: 1,
      lastRequest: serverTimestamp(),
    });
    return true;
  }

  const data = snapshot.data();
  const lastRequestTime =
    data.lastRequest instanceof Timestamp ? data.lastRequest.toMillis() : now; // 타임스탬프 없으면 현재 시간 간주

  if (now - lastRequestTime > ONE_MINUTE) {
    // 1분 지남: 카운트 리셋
    await updateDoc(ref, {
      count: 1,
      lastRequest: serverTimestamp(),
    });
    return true;
  } else {
    // 1분 이내
    if (data.count >= 5) {
      return false; // 5회 초과 차단
    }
    // 카운트 증가
    await updateDoc(ref, {
      count: data.count + 1,
    });
    return true;
  }
}

/**
 * @desc 사용자의 자연어 쿼리를 분석하여 여행 조건을 추출하는 함수입니다.
 * 보안 로직: 입력값 검증 및 Rate Limiting 포함
 * @param query 사용자가 입력한 여행 관련 검색어 (예: "부산 맛집 여행")
 */
// ... existing code ...

/**
 * @desc 주어진 장소 이름 목록에 해당하는 Firebase 데이터를 일괄 조회
 */
export async function getPlacesByNames(names: string[]): Promise<FirebasePlace[]> {
  if (!names || names.length === 0) return [];
  
  console.log(`[Server] getPlacesByNames called with ${names.length} names:`, names.slice(0, 5));

  const placesRef = collection(db, "PLACES");
  const uniqueNames = Array.from(new Set(names)).filter(n => n.trim() !== "");
  // [Modified] Prevent excessive query error as requested by user
  if (uniqueNames.length > 30) {
      console.warn(`[Server] Too many places to fetch (${uniqueNames.length}). Skipping DB fetch to prevent error.`);
      return [];
  }

  const chunks = [];
  
  // Firestore 'in' query supports max 10 items. Chunk it.
  for (let i = 0; i < uniqueNames.length; i += 10) {
    chunks.push(uniqueNames.slice(i, i + 10));
  }

  const results: FirebasePlace[] = [];

  try {
    const promises = chunks.map(async (chunk) => {
      // NAME 필드 기준 정확한 매칭
      const q = query(placesRef, where("NAME", "in", chunk));
      const snapshot = await getDocs(q);
      const chunkResults: FirebasePlace[] = [];
      snapshot.forEach(doc => {
        chunkResults.push(doc.data() as FirebasePlace);
      });
      console.log(`[Server] Chunk result: ${chunk.length} requested -> ${chunkResults.length} found.`);
      return chunkResults;
    });

    const chunkedResults = await Promise.all(promises);
    chunkedResults.forEach(r => results.push(...r));
    
    console.log(`[Server] Total matched places: ${results.length}`);
    return results;
  } catch (error) {
    console.error("[Server] 일괄 장소 조회 실패:", error);
    return [];
  }
}

/**
 * @desc 사용자의 자연어 쿼리를 분석하여 여행 조건을 추출하는 함수입니다.
 * ...
 */
export async function extractTravelContext(
  query: string
): Promise<TravelContext> {
  // ... (existing code for headers, ratelimit) ...
  const headersList = await headers();
  const ip = headersList.get("x-forwarded-for")?.split(",")[0] || "unknown";

  // 1. 입력값 검증: 길이 제한 (50자)
  if (query.length > 50) {
    throw new Error("검색어는 50자 이내여야 합니다.");
  }

  // 2. 입력값 검증: 스크립트 태그 방지 (간이 XSS 방어)
  if (/<script/i.test(query)) {
    throw new Error("허용되지 않는 입력이 포함되어 있습니다.");
  }

  // 3. Rate Limiting 체크
  const isAllowed = await checkRateLimit(ip);
  if (!isAllowed) {
    throw new Error("요청이 너무 많습니다. 잠시 후 다시 시도해주세요.");
  }

  const today = new Date().toISOString().split("T")[0]; // YYYY-MM-DD

    const prompt = `
    # Role
너는 Firebase 기반 여행 서비스의 수석 데이터 엔지니어다. 생성된 JSON은 별도의 변환 없이 사장님의 Firebase DB에 저장되고 UI(image_b0f392.jpg)에 즉시 렌더링되어야 한다.

# 핵심 미션 (Strict Logic)
0. **Quantity Control**: 
   - 각 Day당 최소 6개 이상의 장소(식당, 카페 포함)를 무조건 포함하라.
   - 1박 2일 총합 12~14개의 장소를 제안하라.
1. **Accommodation Anchoring (숙소 고정)**: 
   - 1박 이상의 일정에서 Day N의 마지막 장소는 반드시 'CATEGORY.main: "숙박"'이어야 한다.
   - Day N+1의 첫 번째 장소는 이전 날(Day N)의 마지막 숙소와 동일해야 한다. (숙소에서 나오는 것부터 시작)
2. **Field Mapping (DB 동기화)**: Firebase 콘솔(image_befff1.png)에 정의된 필드명(대소문자 포함)을 100% 준수하라.
3. **Route Optimization**: 지리적 좌표(LOC_LAT, LOC_LNG)를 분석하여 이동 거리를 최소화하고 동선이 꼬이지 않게 하라.
4. **TAGS에는 여행일정의 해당 분기에 맞는 계절의 태그를 들고와서 보여줘야한다. 예를 들어 1월이면 winter 태그를 추가하고, 6월이면 summer 태그를 추가한다.
5. **No Rounding**: 좌표(LOC_LAT, LOC_LNG) 값은 데이터에 잇는 값 그대로 출력 절대 수정하지 마라.

# Output JSON Schema (Firebase & UI 매핑)
{
  "theme": "AI가 선정한 이번 여행의 고유 테마명 (예: 동부 감성 로드)",
  "itinerary": [
    {
      "day": number,
      "date": "YYYY-MM-DD",
      "places": [
        {
          "NAME": "장소명",
          "CATEGORY": { "main": "관광지|식당|카페|숙박", "sub": "세부 유형" },
          "IMAGE_URL": "장소의 특징을 보여주는 실제 같은 이미지 주소",
          "LOC_LAT": string, 
          "LOC_LNG": string,
          "ADDRESS": "상세 주소 전체",
          "STAY_TIME": "예상 체류 시간 (예: 1시간 30분)",
          "TRAVEL_TIME_TO_NEXT": "다음 장소까지의 이동 시간 (예: 40분 이동)",
          "IS_AFLT": false,
          "RATING": number,
          "TAGS": {
            "winter": ["#따뜻한국물", "#겨울바다"],
          },
          "MEMO": "전문 가이드 스타일의 메모",
          "VISIT_ORDER": number
        }
      ]
    }
  ]
}

# IMPORTANT RULES:
1. **Standard JSON**: 반드시 표준 JSON 형식을 준수하라.
2. **Lower-case Boolean**: IS_AFLT 등 모든 불리언 값은 무조건 소문자 'false' 또는 'true'로 작성하라.
3. **No Extra Text**: JSON 데이터 외에 어떤 텍스트도 출력하지 마라.

# User Request
"${query}"
- 오늘 날짜: ${today}
- 위 내용을 바탕으로 1박2일(또는 입력된 기간) 일정을 JSON으로 작성하라.
  `;
  // ... (rest of the function)

interface AIResponse {
  theme: string;
  itinerary: {
    day: number;
    date: string;
    places: {
      NAME: string;
      name?: string; // Fallback
      CATEGORY: { main: string; sub: string };
      IMAGE_URL: string;
      image_url?: string; // Fallback
      LOC_LAT: number;
      loc_lat?: number; // Fallback
      coordinates?: { lat: number; lng: number }; // Fallback
      LOC_LNG: number;
      loc_lng?: number; // Fallback
      ADDRESS: string;
      address?: string; // Fallback
      STAY_TIME: string;
      stay_time?: string; // Fallback
      recommendedDuration?: string; // Fallback
      TRAVEL_TIME_TO_NEXT: string;
      IS_AFLT: boolean;
      RATING: number;
      TAGS: {
        winter?: string[];
        common?: string[];
        [key: string]: string[] | undefined;
      };
      MEMO: string;
      memo?: string; // Fallback
      VISIT_ORDER: number;
    }[];
  }[];
}

  try {
    const result = await geminiModel.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    console.log("[Gemini] Raw response:", text);

    // Extract JSON from markdown code block if present
    const jsonStr = text.replace(/```json|```/g, "").trim();
    const parsedData = JSON.parse(jsonStr) as AIResponse;

    // Calculate end date based on actual itinerary days
    const maxDay = parsedData.itinerary?.reduce((max, day) => Math.max(max, day.day), 1) || 1;
    const endDate = new Date(today);
    endDate.setDate(endDate.getDate() + (maxDay - 1));
    const endDateStr = endDate.toISOString().split("T")[0];

    // Map new schema to TravelContext structure with rich data
    const mappedData: TravelContext = {
      destination: query, // Use query as fallback destination
      theme: parsedData.theme ? [parsedData.theme] : [],
      party: { adult: 2, child: 0 }, 
      dateRange: { start: today, end: endDateStr }, 
      itinerary: parsedData.itinerary?.map((day) => ({
        day: day.day,
        date: day.date,
        places: day.places.map((place) => {
          // Map Korean CATEGORY.main to internal 'type'
          let internalType: PlanItem['type'] = 'etc';
          const mainCat = place.CATEGORY?.main || '';
          if (mainCat.includes('식당')) internalType = 'food';
          else if (mainCat.includes('카페')) internalType = 'cafe';
          else if (mainCat.includes('숙박')) internalType = 'stay';
          else if (mainCat.includes('관광지')) internalType = 'sightseeing';

          // Flatten TAGS object into KEYWORDS array for backward compatibility
          // [Modified] Pick the first available tag array (e.g. winter, summer, common) as requested by user
          let extractedTags: string[] = [];
          if (place.TAGS) {
            const firstTagKey = Object.keys(place.TAGS)[0];
            if (firstTagKey && Array.isArray(place.TAGS[firstTagKey])) {
                extractedTags = place.TAGS[firstTagKey]!;
            }
          }
          
          const keywords = extractedTags.map(tag => tag.startsWith('#') ? tag.slice(1) : tag);

          // [Robustness] Normalize keys (AI might return lowercase)
          const aiName = place.NAME || place.name;
          const aiLat = place.LOC_LAT || place.loc_lat || place.coordinates?.lat || 37.5665; // Default Seoul if missing
          const aiLng = place.LOC_LNG || place.loc_lng || place.coordinates?.lng || 126.9780;
          const aiAddress = place.ADDRESS || place.address || "";
          const aiImage = place.IMAGE_URL || place.image_url || null;
          const aiMemo = place.MEMO || place.memo || "";
          
          // Stay Time parsing
          let stayTimeVal: string | number | undefined = place.STAY_TIME || place.stay_time || place.recommendedDuration;
          if (!stayTimeVal) {
             if (internalType === 'stay') stayTimeVal = 720;
             else if (internalType === 'sightseeing') stayTimeVal = 90;
             else stayTimeVal = 60;
          }

          return {
            _docId: `ai_${Math.random().toString(36).substr(2, 9)}`,
            PLACE_ID: `ai_${Math.random().toString(36).substr(2, 9)}`,
            NAME: aiName,
            ADDRESS: aiAddress,
            CATEGORY: {
               main: place.CATEGORY?.main || "AI추천",
               sub: place.CATEGORY?.sub || internalType
            },
            LOC_LAT: aiLat,
            LOC_LNG: aiLng,
            IMAGE_URL: aiImage,
            GALLERY_IMAGES: null,
            MAP_LINK: "",
            AFFIL_LINK: null,
            IS_AFLT: false,
            IS_TICKET_REQUIRED: false,
            TIME_INFO: null,
            PARKING_INFO: null,
            REST_INFO: null,
            FEE_INFO: null,
            DETAILS: {},
            RATING: place.RATING || 0,
            HIGHTLIGHTS: aiMemo ? [aiMemo] : [], // Use MEMO as highlight
            MEMO: aiMemo,
            KEYWORDS: keywords,
            NAME_GRAMS: [],
            
            day: day.day,
            time: `${String(8 + place.VISIT_ORDER * 2).padStart(2, '0')}:00`,
            type: internalType,
            STAY_TIME: stayTimeVal,
            PRICE_GRADE: 0,
            STATS: { bookmark_count: 0, view_count: 0, review_count: 0, rating: place.RATING || 0, weight: 1 },
            TAGS: place.TAGS || { spring: null, summer: null, autumn: null, winter: null },
            isLocked: false,
            is_indoor: false
          } as unknown as PlanItem;
        })
      })) || []
    };

    return mappedData;
  } catch (error) {
    console.error("[Gemini] Error extracting context:", error);
    // Fallback in case of error
    return {
      destination: null,
      theme: [],
      party: { adult: 2, child: 0 },
      dateRange: { start: today, end: today },
    };
  }
}
